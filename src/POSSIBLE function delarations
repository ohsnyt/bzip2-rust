// The C source used defined constants. It would be much safer to use enums, which
// makes it harder to use the wrong types in the wrong place. I will use
// C style enums which have specified values, which will make the code safe
// while hopefully providing the (int) value that the external caller needs.

// Since these are used internally, I will shift to the normal Rust CamelCase style.
// It will be important to keep these synced with the bzip.h definitions.

/// Return values for public API functions
#[repr(C)]
pub enum BzStatus {
    BzOk = 0,
    BzRunOk = 1,
    BzFlushOk = 2,
    BzFinishOk = 3,
    BzStreamEnd = 4,
    BzSequenceError = (-1),
    BzParamError = (-2),
    BzMemError = (-3),
    BzDataError = (-4),
    BzDataErrorMagic = (-5),
    BzIoError = (-6),
    BzUnexpectedEof = (-7),
    BzOutbuffFull = (-8),
    BzConfigError = (-9),
}

/// Caller accessible struct used for compression and decompression.
#[repr(C)]
pub struct Bz_Stream {
    /// C pointer to the next bytes to read.
    next_in: *const c_char,
    /// Amount of data available to be processed through next_in.
    avail_in: c_uint,

    /// Returns the total amount of data received by the library, 64 bit counts
    total_in_lo32: c_uint,
    total_in_hi32: c_uint,

    /// C pointer to location to write the bytes being returned.
    next_out: *mut c_char,
    /// Amount of space available to write data through next_out.
    avail_out: c_uint,

    /// Returns total amount of data passed out of the library. 64 bit counts
    total_out_lo32: c_uint,
    total_out_hi32: c_uint,

    /// Pointer to retain ownership of private data carried between function calls.
    state: *mut c_void,

    /// Pointers to  "Custom memory allocators". We just ignore this and let
    /// Rust manage allocation/drops.
    bzalloc: (*const c_void, c_int, c_int),
    bzfree: (*const c_void, *const c_void),
    opaque: *const c_void,
}

/// Private struct used to hold data used in the program.
///  EState* s;

//        blockSize100k < 1 || blockSize100k > 9 ||
//        workFactor < 0 || workFactor > 250)
//      return BZ_PARAM_ERROR;

//    if (workFactor == 0) workFactor = 30;
//    if (strm->bzalloc == NULL) strm->bzalloc = default_bzalloc;
//    if (strm->bzfree == NULL) strm->bzfree = default_bzfree;

//    s = BZALLOC( sizeof(EState) );
//    if (s == NULL) return BZ_MEM_ERROR;
//    s->strm = strm;

//    s->arr1 = NULL;
//    s->arr2 = NULL;
//    s->ftab = NULL;

//    n       = 100000 * blockSize100k;
//    s->arr1 = BZALLOC( n                  * sizeof(UInt32) );
//    s->arr2 = BZALLOC( (n+BZ_N_OVERSHOOT) * sizeof(UInt32) );
//    s->ftab = BZALLOC( 65537              * sizeof(UInt32) );

//    if (s->arr1 == NULL || s->arr2 == NULL || s->ftab == NULL) {
//       if (s->arr1 != NULL) BZFREE(s->arr1);
//       if (s->arr2 != NULL) BZFREE(s->arr2);
//       if (s->ftab != NULL) BZFREE(s->ftab);
//       if (s       != NULL) BZFREE(s);
//       return BZ_MEM_ERROR;
//    }

//    s->blockNo           = 0;
//    s->state             = BZ_S_INPUT;
//    s->mode              = BZ_M_RUNNING;
//    s->combinedCRC       = 0;
//    s->blockSize100k     = blockSize100k;
//    s->nblockMAX         = 100000 * blockSize100k - 19;

struct State {
    options: BzOpts,
    action: u32,
    block_num: u32,
    state: State,
    mode: Mode,
    combined_crc: u32,
    block_size_100k: u8,
    nblock_max: u32,
    verbosity: Verbosity,
    work_factor: WorkFactor,
    block: Vec<u8>,
    mtfv: Vec<u16>,
    zbits: u32, // ??
    ptr: usize, //pointer to arr1??
}
impl State {
    fn new() -> Self {
        Self {
            options: BzOpts::new(),
            action: Action::IDLE,
            block_num: 0,
            state: State::IDLE,
            mode: Mode::Test ,
            combined_crc: 0,
            block_size_100k: 9,
            nblock_max: 900000 - 19,
            verbosity: Verbosity,
            work_factor: WorkFactor,
            block: Vec::new(),
            mtfv: Vec::new(),
            zbits: BitWriter::new(), 
            ptr: 0, //pointer to arr1??
        }
    }
}

/// Current state of the machine. Rust implementation of caller constants.
#[repr(C)]
enum Action {
    IDLE = 1,
    RUN = 2,
    FLUSH = 3,
    FINISH = 4,
}

/// C constants passed in through FFI
const BZ_M_IDLE: c_int = 1;
const BZ_M_RUNNING: c_int = 2;
const BZ_M_FLUSHING: c_int = 3;
const BZ_M_FINISHING: c_int = 4;

/*-- Core (low-level) library functions --*/
/// Initialize compression routine. Requires pointer to data and three C ints.
/// Returns an Int, which is an error/success code/number.
#[no_mangle]
pub extern "C" fn BZ2_bzCompressInit(
    strm: *mut c_void,
    block_size100k: c_int, // Int of 0-9
    verbosity: c_int,      // Int of 0-4
    work_factor: c_int,    // Int of 0-250
) -> BzStatus {
    let strm: &mut Bz_Stream = unsafe { &mut *(strm as *mut Bz_Stream) };
    strm.state = State::new();
    strm.state.options.block_size = block_size100k as u8;
    strm.state.options.verbosity = match verbosity {
        0 => Verbosity::Quiet,
        1 => Verbosity::Errors,
        4 => Verbosity::Chatty,
        _ => Verbosity::Normal,
    };
    strm.state.options.work_factor = match work_factor {
        0..10 => WorkFactor::Fallback,
        _ => WorkFactor::Normal,
    };
    todo!()
      Int32   n;
  

   strm->state          = s;
   strm->total_in_lo32  = 0;
   strm->total_in_hi32  = 0;
   strm->total_out_lo32 = 0;
   strm->total_out_hi32 = 0;
   init_RL ( s );
   prepare_new_block ( s );
   return BZ_OK;
}

/// Do the compression. BZ2_bzCompressInit must be called first.
/// Returns an Int, which is an error/success code/number.
#[no_mangle]
pub extern "C" fn BZ2_bzCompress(strm: *mut c_void, action: c_int) -> BzStatus {
    let strm: &mut Bz_Stream = unsafe { &mut *(strm as *mut Bz_Stream) };
    strm.state.action = match action {
        2 => Action::RUN,
        3 => Action::FLUSH,
        4 => Action::FINISH,
        _ => Action::IDLE,
    };
    todo!();
}

/// Call to clean up and flush buffers.
/// Returns an Int, which is an error/success code/number.
#[no_mangle]
pub extern "C" fn BZ2_bzCompressEnd(strm: *mut c_void) -> BzStatus {
    let strm: &mut Bz_Stream = unsafe { &mut *(strm as *mut Bz_Stream) };
    todo!()
}

/// Initialize decompression routine. Requires a pointer where we can reference the
/// private compression settings/data, a verbosity setting, and switch
/// to use small memory model. Returns an error/success code/number as a c_int.
#[no_mangle]
pub extern "C" fn BZ2_bzDecompressInit(
    strm: *mut c_void,
    verbosity: c_int, // Int of 0-4. Rust would use an enum
    small: c_int, // If nonzero,  use an alternative decompression algorithm which uses less memory
) -> BzStatus {
    let strm: &mut Bz_Stream = unsafe { &mut *(strm as *mut Bz_Stream) };
    let x = BzStream::new();
    strm.state.options.verbosity = verbosity;
    strm.state.options.small = small;
}

/// Do the decompression. BZ2_bzDecompressInit must be called first.
/// Returns an Int, which is an error/success code/number.
#[no_mangle]
pub extern "C" fn BZ2_bzDecompress(
    strm: Bz_Stream, // NOTE: This is NOT FFI Safe. Reference to Bz_Stream struct, which contains Vec<u8>.
) -> BzStatus {
    todo!()
}

/// Call to clean up and flush buffers.
/// Returns an Int, which is an error/success code/number.
#[no_mangle]
pub extern "C" fn BZ2_bzDecompressEnd(
    strm: Bz_Stream, // NOTE: This is NOT FFI Safe. Reference to Bz_Stream struct, which contains Vec<u8>.
) -> BzStatus {
    todo!()
}

/*-- High(er) level library functions --*/
// Need to understand how to do conditional inclusion for C lib
//#ifndef BZ_NO_STDIO

const BZ_MAX_UNUSED: c_uint = 5000;

/// Prepare to read file of compressed data. Is given a C style file handle of a file already
/// opened for reading. Oddly this doesn't pass in the strm pointer, so we need to find
/// a way to interact with our options.
#[no_mangle]
pub extern "C" fn BZ2_bzReadOpen(
    bzerror: *mut c_uint, // Returns error conditions here
    f: File,              // C file handle opened externally to this function
    verbosity: c_int,
    small: c_int, // If nonzero,  use an alternative decompression algorithm which uses less memory
    unused: c_void,
    n_unused: c_int,
) -> File {
    // Original returned the "asbstract pointer BZFILE" or null
    todo!()
}

/// Closes the file, not really needed in Rust.
#[no_mangle]
pub extern "C" fn BZ2_bzReadClose(
    bzerror: &mut c_int, // Returns error conditions here rather than from the function return
    b: File,             // The "abstract pointer BZFILE" returned by BZ2_bzReadOpen
) {
    todo!()
}

///Returns data which was read from the compressed file but was not needed to get to the logical end-of-stream.
/// unused is set to the address of the data, and nUnused to the number of bytes.
/// n_unused will be set to a value between 0 and BZ_MAX_UNUSED inclusive.
#[no_mangle]
pub extern "C" fn BZ2_bzReadGetUnused(
    bzerror: &mut c_int, // Returns error conditions here rather than from the function return
    b: File,             // The "abstract pointer BZFILE" returned by BZ2_bzReadOpen
    unused: c_void,
    n_unused: c_int,
) {
    todo!()
}

///Reads up to len (uncompressed) bytes from the compressed file b into the buffer buf
#[no_mangle]
pub extern "C" fn BZ2_bzRead(
    bzerror: &mut c_int, // Returns error conditions here rather than from the function return
    b: File,             // The "abstract pointer BZFILE" returned by BZ2_bzReadOpen
    buf: c_void,         // Location where data is put
    len: c_int,          // Length of data requested
) {
    todo!()
}
/// Prepare to write file of compressed data. Is given a C style file handle of a file already
/// opened for writing. (This sucks. Rust does all of this so well.) Errors are returned
/// through bzerror. Returns file pointer "BZFILE" or null. We could do null, though it is bad Rust.
#[no_mangle]
pub extern "C" fn BZ2_bzWriteOpen(
    bzerror: &mut c_uint, // Returns error conditions here rather than from the function return
    f: File,              // C file handle opened externally to this function
    block_size100k: c_int, // 1-9
    verbosity: c_int,     //0-4
    work_factor: c_int,   //0-250
) -> File {
    // Original returned the "asbstract pointer BZFILE" or null
    todo!()
}

/// Writes len amount of data to the file buffer
#[no_mangle]
pub extern "C" fn BZ2_bzWrite(
    bzerror: &mut c_int, // Returns error conditions here rather than from the function return
    b: File,             // The "abstract pointer BZFILE" returned by BZ2_bzWriteOpen
    buf: c_void,         // Location where data is put
    len: c_int,          // Length of data requested
) {
    todo!()
}

/// Closes the file, not really needed in Rust except to report data amounts.
#[no_mangle]
pub extern "C" fn BZ2_bzWriteClose(
    bzerror: &mut c_uint, // Returns error conditions here rather than from the function return
    b: File,              // The "abstract pointer BZFILE" returned by BZ2_bzWriteOpen
    abandon: c_int,       // Non-zero: Force no attempt to complete compression or fflush
    nbytes_in: c_uint,    //total volume of uncompressed data handled
    nbytes_out: c_uint,   //total volume of compressed data written
) {
    todo!()
}

/// Identical to BZ2_bzWriteClose, but with 64 bit values returned
#[no_mangle]
pub extern "C" fn BZ2_bzWriteClose64(
    bzerror: &mut c_uint, // Returns error conditions here rather than from the function return
    b: File,              // The "abstract pointer BZFILE" returned by BZ2_bzWriteOpen
    abandon: c_int,       // Non-zero: Force no attempt to complete compression or fflush
    nbytes_in_lo32: c_uint, //total volume of uncompressed data handled
    nbytes_in_hi32: c_uint, //total volume of uncompressed data handled
    nbytes_out_lo32: c_uint, //total volume of compressed data written
    nbytes_out_hi32: c_uint, //total volume of compressed data written
) {
    todo!()
}

/*-- Utility functions for in memory compression and decompression --*/
/// Compress data
#[no_mangle]
pub extern "C" fn BZ2_bzBuffToBuffCompress(
    dest: POINTER,         // Destination buffer for the data
    dest_len: c_uint,      // Length of data to write
    source: POINTER,       // Source buffer of the data
    source_len: c_uint,    // Length of data to read
    block_size100k: c_int, // 1-9
    verbosity: c_int,      //0-4
    work_factor: c_int,    //0-250
) {
    todo!()
}

/// Decompress data
#[no_mangle]
pub unsafe extern "C" fn BZ2_bzBuffToBuffDecompress(
    dest: POINTER,         // Destination buffer for the data
    dest_len: *mut c_uint, // Length of data to write
    source: POINTER,       // Source buffer of the data
    source_len: c_uint,    // Length of data to read
    small: u8, // If nonzero,  use an alternative decompression algorithm which uses less memory
    verbosity: c_uint, //0-4
) {
    if let Some(a) = dest_len.as_mut() {
        //put something into dest_len
    }
    todo!()
}

/*--
   Code contributed by Yoshioka Tsuneo (tsuneo@rr.iij4u.or.jp)
   to support better zlib compatibility.
   This code is not _officially_ part of libbzip2 (yet);
   I haven't tested it, documented it, or considered the
   threading-safeness of it.
   If this code breaks, please contact both Yoshioka and me.
--*/

/// Return the version number
#[no_mangle]
pub extern "C" fn BZ2_bzlibVersion() -> String {
    todo!()
}

/// Analogous to fopen for compression function
#[no_mangle]
pub extern "C" fn BZ2_bzopen(
    path: &str, // NOT SURE - see C language fopen()
    mode: char, // NOT SURE - see C language fdopen()
) -> File {
    // Original returned the "asbstract pointer BZFILE" or null
    todo!()
}

/// Analogous to fdopen for compression function
#[no_mangle]
pub extern "C" fn BZ2_bzdopen(
    fd: i32,    // NOT SURE - see C language fdopen()
    mode: char, // NOT SURE - see C language fdopen()
) -> File {
    // Original returned the "asbstract pointer BZFILE" or null
    todo!()
}

#[no_mangle]
pub extern "C" fn BZ2_bzread(
    b: File,      // File handle
    buf: Vec<u8>, // Location where data is put
    len: c_uint,  // Length of data to read
) {
    todo!()
}

#[no_mangle]
pub extern "C" fn BZ2_bzwrite(
    b: File,      // File handle
    buf: Vec<u8>, // Location where data is put
    len: c_uint,  // Length of data written
) -> c_uint {
    todo!()
}

#[no_mangle]
pub extern "C" fn BZ2_bzflush(b: File, // File handle
) -> c_uint {
    todo!()
}

#[no_mangle]
pub extern "C" fn BZ2_bzclose(b: File, // File handle
) {
    todo!()
}

#[no_mangle]
pub extern "C" fn BZ2_bzerror(
    b: File,     // File handle
    errnum: i32, // Error returned. Should be C style enum.
) -> char {
    todo!();
}

/*-------------------------------------------------------------*/
/*--- end                                           bzlib.h ---*/
/*-------------------------------------------------------------*/

use std::{
    ffi::c_void,
    fs::File,
    os::raw::{c_char, c_int, c_uint},
};
